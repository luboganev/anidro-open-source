package app.anidro.renderers;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Path;
import android.graphics.PointF;
import android.graphics.PorterDuff;

import androidx.annotation.ColorInt;
import androidx.annotation.NonNull;

import java.util.ArrayList;
import java.util.List;

import app.anidro.models.TimedSegment;

/**
 * This class is responsible for rendering the frames containing the parts of the drawing visible
 * at a particular time. The total number of frames produced depends on the input frame rate,
 * as well as the length of the input drawing.
 * <p/>
 * Created by luboganev on 19/09/15.
 */
public class FixedFrameRateRenderer {
    public static final long ANIMATION_FINAL_FRAME_EXTRA_LENGTH = 2000;

    public static final long GIF_FRAME_LENGTH = 100;
    public static final long VIDEO_FRAME_LENGTH = 33;
    public static final long PREVIEW_FRAME_LENGTH = 16;

    private final Canvas frameCanvas;
    private final Bitmap frameBitmap;
    private final List<List<TimedSegment>> frames = new ArrayList<>();
    private final @ColorInt
    int backgroundColor;
    private int currentFrame;
    private final long frameLength;

    public FixedFrameRateRenderer(@NonNull List<TimedSegment> drawing,
                                  @ColorInt int backgroundColor,
                                  int frameWidth, int frameHeight,
                                  @NonNull DrawingTimeNormalizer normalizer, long frameLength,
                                  @NonNull Bitmap.Config frameConfig) {

        // Init the canvas
        frameBitmap = Bitmap.createBitmap(frameWidth, frameHeight, frameConfig);
        frameCanvas = new Canvas(frameBitmap);
        this.backgroundColor = backgroundColor;

        // Init frame properties
        currentFrame = 0;
        this.frameLength = frameLength;

        // Adjust the drawing width and height
        for (TimedSegment segment : drawing) {
            segment.adjustCanvasSize(frameWidth, frameHeight);
        }

        // Init the drawing frames
        initFrames(drawing, normalizer);
    }

    /**
     * Adds delay to the last frame artificially by redrawing it
     * multiple times. The exact number of times depends on the
     * frame rate and the input delay.
     */
    public void addFinalFrameExtraDelay(long delay) {
        // Add the delay of the final frame
        int lastFrameRepeatCount = (int) (delay / frameLength);
        // Add empty frames
        final List<TimedSegment> frameSegments = new ArrayList<>();
        for (int i = 0; i < lastFrameRepeatCount; i++) {
            frames.add(frameSegments);
        }
    }

    /**
     * Cleans up some memory. After this call, the {@link FixedFrameRateRenderer} can no longer be used
     */
    public void destroy() {
        frameBitmap.recycle();
    }

    /**
     * Returns the current frame length of this renderer
     */
    public long getFrameLength() {
        return frameLength;
    }

    /**
     * Returns the width of the frame of this renderer
     */
    public int getFrameWidth() {
        return frameBitmap.getWidth();
    }

    /**
     * Returns the height of the frame of this renderer
     */
    public int getFrameHeight() {
        return frameBitmap.getHeight();
    }

    /**
     * Returns the total number of unique frames generated by this renderer
     */
    public int getFramesCount() {
        return frames.size();
    }

    /**
     * Returns the index of the currently rendered frame
     */
    public int getCurrentFrameIndex() {
        return currentFrame;
    }

    /**
     * Resets the current frame to the fist frame of the renderer
     */
    public void resetRenderer() {
        frameCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
        frameCanvas.drawColor(backgroundColor);
        currentFrame = 0;
    }

    /**
     * Renders the next frame if it has not reached the last one
     */
    public void renderNextFrame() {
        if (currentFrame >= frames.size()) {
            return;
        }

        renderCurrentFrame();
        currentFrame++;
    }

    /**
     * Checks if there is a next frame to be rendered
     */
    public boolean hasNextFrame() {
        return currentFrame < frames.size();
    }

    /**
     * Returns the {@link Bitmap} containing the current frame
     */
    public Bitmap getCurrentFrame() {
        return frameBitmap;
    }

    /**
     * Renders all frames from the current to the input frame index
     */
    public void renderFrame(int frameIndex) {
        if (frameIndex >= frames.size()) {
            frameIndex = frames.size() - 1;
        }

        if (frameIndex < 0) {
            frameIndex = 0;
        }

        if (currentFrame > frameIndex) {
            resetRenderer();
        }

        while (currentFrame <= frameIndex) {
            renderCurrentFrame();
            currentFrame++;
        }
    }

    /**
     * Draws the current frame index onto the canvas by drawing all
     * segments contained in it.
     */
    private void renderCurrentFrame() {
        List<TimedSegment> currentFrame = frames.get(this.currentFrame);
        PointF currentPoint, controlPoint;
        Path drawingPath = new Path();

        for (TimedSegment segment : currentFrame) {
            drawingPath.reset();
            if (!segment.isEmpty()) {
                currentPoint = segment.getPoint(0);
                drawingPath.moveTo(currentPoint.x, currentPoint.y);

                if (segment.getPointsCount() > 2) {
                    for (int i = 1; i < segment.getPointsCount() - 1; i++) {
                        controlPoint = segment.getPoint(i);
                        currentPoint = segment.getPoint(i + 1);
                        drawingPath.quadTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
                    }
                    frameCanvas.drawPath(drawingPath, segment.getPaint());
                } else if (segment.getPointsCount() > 1) {
                    controlPoint = currentPoint;
                    currentPoint = segment.getPoint(1);
                    if (controlPoint.equals(currentPoint.x, currentPoint.y)) {
                        frameCanvas.drawPoint(currentPoint.x, currentPoint.y, segment.getPaint());
                    } else {
                        drawingPath.lineTo(currentPoint.x, currentPoint.y);
                        frameCanvas.drawPath(drawingPath, segment.getPaint());
                    }
                } else {
                    frameCanvas.drawPoint(currentPoint.x, currentPoint.y, segment.getPaint());
                }
            }
        }
    }

    /**
     * Normalizes the input drawing and then chops it into collections of segments for each frame
     * to be rendered.
     */
    private void initFrames(List<TimedSegment> drawing, DrawingTimeNormalizer normalizer) {
        resetRenderer();
        frames.clear();

        normalizer.normalizeDrawing(drawing);
        final List<TimedSegment> normalizedDrawing = normalizer.getNormalizedDrawing();
        final long normalizedDuration = normalizer.getNormalizedDuration();

        long currentTime = 0;
        List<TimedSegment> frameSegments;
        int segmentIndex = 0;
        TimedSegment subSegment;
        while (currentTime <= normalizedDuration && segmentIndex < normalizedDrawing.size()) {
            frameSegments = new ArrayList<>();

            for (TimedSegment segment : normalizedDrawing) {
                if (segment.hasPointsInInterval(currentTime, currentTime + frameLength)) {
                    subSegment = segment.getSubSegment(currentTime, frameLength);
                    frameSegments.add(subSegment);
                }
            }

            frames.add(frameSegments);
            currentTime += frameLength;
        }
    }
}
